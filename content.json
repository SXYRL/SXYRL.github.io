{"meta":{"title":"闫瑞龙的个人博客","subtitle":null,"description":null,"author":"闫瑞龙","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2018-02-28T13:39:07.000Z","updated":"2018-02-28T13:40:27.611Z","comments":true,"path":"tags/index1.html","permalink":"http://yoursite.com/tags/index1.html","excerpt":"","text":""},{"title":"","date":"2018-02-28T13:40:14.186Z","updated":"2018-02-28T13:40:14.186Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-02-28T13:40:53.000Z","updated":"2018-02-28T13:40:53.025Z","comments":true,"path":"categories/index1.html","permalink":"http://yoursite.com/categories/index1.html","excerpt":"","text":""},{"title":"","date":"2018-02-28T13:41:16.976Z","updated":"2018-02-28T13:41:16.976Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"python之常用模块块","slug":"常用模块","date":"2017-09-10T03:13:01.000Z","updated":"2017-09-24T15:25:10.230Z","comments":true,"path":"2017/09/10/常用模块/","link":"","permalink":"http://yoursite.com/2017/09/10/常用模块/","excerpt":"","text":"python有一套很有用的标准库，标准库会随着python解释器，一起安装在你的电脑中的。它是python的一个组成部分，这些标准库是Python为你准备号的利器，可以让编程事半功倍。 标准库 说明 builtins 内建函数默认加载 os 操作系统接口 sys Python自身的运行环境 functools 常用的工具 json 编码和解码JSON对象 logging 记录日志，调试 multiprocessing 多进程 threading 多线程 copy 拷贝 time 时间 datetime 日期和时间 calendar 日历 hashlib 加密算法 random 生成随机数 re 字符串正则匹配 socket 标准的BSD Sockets API shutil 文件和目录管理 glob 基于文件通配符搜索 1，hashlib 加密算法，主要用于注册登录加密 &gt;&gt;&gt; import hashlib &gt;&gt;&gt; t = hashlib.md5() #创建hash对象，md5 &gt;&gt;&gt; t.update(b’yanruilong’) #更新哈希对象传一个字符串参数 &gt;&gt;&gt; t.hexdigest() #返回十六进制数字字符串 ‘3e0474ae09c74b6276d23eb56b1209da’","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"常用模块","slug":"常用模块","permalink":"http://yoursite.com/tags/常用模块/"}]},{"title":"python之property","slug":"property","date":"2017-09-10T03:13:01.000Z","updated":"2017-09-23T14:59:35.658Z","comments":true,"path":"2017/09/10/property/","link":"","permalink":"http://yoursite.com/2017/09/10/property/","excerpt":"","text":"在工作中，在绑定属性的时候，如果我们直接把属性写成全局的，虽然写起来比较简单，但是容易被随便修改，不符合逻辑，这时就需要把该属性进行限制，改成私有属性，通过内部方法进行调用或者修改以及检测 例子： class Test(object): def __init__(self): self.__num = 100 def getNum(self): return self.__num def setNum(self,newNum): if not isinstance(newNum, int): raise ValueError(&apos;该值必须是一个整数！&apos;) if newNum &lt; 0 or newNum &gt; 300: raise ValueError(&apos;该值必须在0 ~ 300!&apos;) self.__num = newNum t = Test() t.getNum()#获取该值 t.setNum(300)#设置该值 上面这种方式有点繁琐，python还有更好的方式，通过属性的方式 class Test(object): def __init__(self): self.__num = 100 def getNum(self): return self.__num def setNum(self,newNum): if not isinstance(newNum, int): raise ValueError(&apos;该值必须是一个整数！&apos;) if newNum &lt; 0 or newNum &gt; 300: raise ValueError(&apos;该值必须在0 ~ 300!&apos;) self.__num = newNum #只需要在这里进行改写 #这里python会自动检测是设置或是获取，如果获取，则执行getNum，如果是设置，则执行setNum，相当于对该方法进行了简单的封装 #这里需要注意的是：获取一定要放在前面，顺序混淆会报错 num = property(getNum,setNum) t = Test() #可以通过这两个方法进行设置和获取以及设置的时候进行验证 #这是只要通过获取或者设置属性的方式就可以实现和上面一样的功能 t.num #等价于上面的t.getNum() t.num = 300 #等价于上面的t.getNum(300) 在这里再介绍一种property的使用方式,通过装饰器的方法进行实现 class Test(object): def __init__(self): self.__num = 100 #通过装饰器的方式进行实现 #这里等价于上面的，getNum()方法 @property def num(self): return self.__num #这里等价于上面的setNum()方法 @num.setter def num(self,newNum): if not isinstance(newNum, int): raise ValueError(&apos;该值必须是一个整数！&apos;) if newNum &lt; 0 or newNum &gt; 300: raise ValueError(&apos;该值必须在0 ~ 300!&apos;) self.__num = newNum 总结： Python内置的@property装饰器就是负责把一个方法变成属性调用的： @property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@num.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作： 注意到这个神奇的@property，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。 还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性： @property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"property","slug":"property","permalink":"http://yoursite.com/tags/property/"}]},{"title":"python之闭包","slug":"闭包","date":"2017-09-10T03:13:01.000Z","updated":"2017-09-23T16:45:51.810Z","comments":true,"path":"2017/09/10/闭包/","link":"","permalink":"http://yoursite.com/2017/09/10/闭包/","excerpt":"","text":"闭包简单理解就是函数内部再定义一个函数，内部定义的函数调用了该函数外部的变量，这种写法就形成了一个闭包。","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"闭包","slug":"闭包","permalink":"http://yoursite.com/tags/闭包/"}]},{"title":"python之动态添加属性方法","slug":"动态添加属性和方法","date":"2017-09-10T03:13:01.000Z","updated":"2017-09-24T07:00:53.481Z","comments":true,"path":"2017/09/10/动态添加属性和方法/","link":"","permalink":"http://yoursite.com/2017/09/10/动态添加属性和方法/","excerpt":"","text":"工作中，我们需要给某一个实例对象新添加一个新的实例方法，如果用添加属性的方法进行添加的话直接会报错： class Person: def __init__(self,newName,newAge): self.name = newName self.age = newAge def eat(self): print(&apos;==={0}正在吃&apos;.format(self.name)) p1 = Person(&apos;p1&apos;,20) p1.eat() def run(self): print(&apos;===={0}正在跑&apos;.format(self.name)) p1.run = run #虽然p1对象中run属性指向了run函数，但是因为run属性指向的函数是后来添加的，调用的时候并没有把p1这个属性传进去，所以会报参数错误 p1.run() 通过查资料发现python提供了一个方法供我们动态的给对象添加一个方法： class Per: def __init__(self,newName): self.name = newName p1 = Per(&apos;p1&apos;) print(p1.name) def run(self): print(&apos;==={0}在跑===&apos;.format(self.name)) #报错 # p1.run = run #p1.run() #这时候我们可以通过一个types模块里的方法实现动态添加方法 import types #这里的第一个参数是要添加的方法，第二个参数是要添加的对象 #然后把它赋给要绑定的这个对象的方法 p1.run = types.MethodType(run,p1) #这时候就可以直接调用新添加的方法了 p1.run() 注意：只有个实例对象动态添加一个方法的时候需要types.MethodType方法而给类添加静态方法和类方法则不需要这种写法 #添加类方法 @classmethod def printNum(cls): print(&apos;classMethod&apos;) Per.printNum = printNum Per.printNum() #添加静态方法 @staticmethod def test(): print(&apos;静态方法&apos;) Per.test = test Per.test() 如果我们想要显示实例的属性怎么办呢？比如我们只允许是实例对象添加name和age属性，为了达到限定的目的，python允许在定义class的时候定义一个特殊的slots变量，来限制该class实例对象可以添加的属性： class Per(object): #这个变量的值必须放在一个元祖中 slots = (‘name’,’age’) p = Per() p.name = ‘呵呵’p.age = 111 print(p.name)print(p.age) p.add = ‘北京’#这里就会报错，找不到p.add这个属性print(p.add)","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"动态添加属性","slug":"动态添加属性","permalink":"http://yoursite.com/tags/动态添加属性/"}]},{"title":"python之内建函数","slug":"内建函数","date":"2017-09-10T03:13:01.000Z","updated":"2017-09-24T13:51:56.612Z","comments":true,"path":"2017/09/10/内建函数/","link":"","permalink":"http://yoursite.com/2017/09/10/内建函数/","excerpt":"","text":"1，map函数 定义：map函数会根据提供的函数对指定序列做映射，生成新的列表 map(function,sequence[,sequence,…]) &gt;&gt;list function是一个函数sequence是一个或者多个学列，取决于function需要几个参数python3中返回的是map对象，需要迭代才能获取对象中的值，可以在外面转换成list对象 参数学列中的每一个元素分别调用function函数，返回包含每次function函数返回的map对象 例1： &gt;&gt;&gt; k = map(lambda x:x*x, [1,2,3]) &gt;&gt;&gt; k &gt;&gt;&gt; for i in k: print(i) 1 4 9 &gt;&gt;&gt; k =list(map(lambda x:x*x, [1,2,3])) &gt;&gt;&gt; k 1 4 9 例2： #函数需要2个参数的情况 &gt;&gt;&gt; m = list(map(lambda x,y:x+y,[1,2,3],[4,5,6])) &gt;&gt;&gt; m [5, 7, 9] 例3：上面两个例子都是用匿名函数的方式，下面来看不使用匿名函数的方式： &gt;&gt;&gt; def f1(x,y): return (x,y) &gt;&gt;&gt; a1 = [1,2,3,4,5,6] &gt;&gt;&gt; a2 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;] &gt;&gt;&gt; list(map(f1,a1,a2)) [(1, &apos;a&apos;), (2, &apos;b&apos;), (3, &apos;c&apos;), (4, &apos;d&apos;), (5, &apos;e&apos;), (6, &apos;f&apos;)] 2，filter 定义：filter函数会对制定序列执行过滤、筛选操作 filter(function or None,squence)&gt;&gt;&gt;list,tuple,or string function:接受一个参数，返回布尔值True或False sequence:序列可以是str,tuple,list filter函数会对序列参数sequence中的每个元素调用function函数，最后返回的结果包含调用结果为True的元素。返回值的类型和参数sequence的类型相同 例1： &gt;&gt;&gt; list(filter(lambda x:x%2,[1,2,3,4,5,6,7,8])) [1, 3, 5, 7] 3，sorted函数 定义：对参数进行排序返回新的列表，如果是字母则通过ASII码进行排序 例1：正序排序 &gt;&gt;&gt; sorted([1,2,3,5,3,12,4,1234,34,343]) [1, 2, 3, 3, 4, 5, 12, 34, 343, 1234] 例2：倒序排序 &gt;&gt;&gt; sorted([4,66,1,65,23,8,5,],reverse = True) [66, 65, 23, 8, 5, 4, 1] 例3：字母排序 &gt;&gt;&gt; sorted([&apos;a&apos;,&apos;c&apos;,&apos;e&apos;,&apos;b&apos;,&apos;f&apos;]) [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;e&apos;, &apos;f&apos;] #如果是单词的话会通过它们首字母的asii码进行排序 &gt;&gt;&gt; sorted([&apos;hello&apos;,&apos;world&apos;,&apos;name&apos;,&apos;args&apos;]) [&apos;args&apos;, &apos;hello&apos;, &apos;name&apos;, &apos;world&apos;]","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"内建函数","slug":"内建函数","permalink":"http://yoursite.com/tags/内建函数/"}]},{"title":"python之对象池","slug":"对象池","date":"2017-09-10T03:13:01.000Z","updated":"2017-09-23T14:07:19.078Z","comments":true,"path":"2017/09/10/对象池/","link":"","permalink":"http://yoursite.com/2017/09/10/对象池/","excerpt":"","text":"1，小整数对象池整数在程序中的使用非常广泛，Python为了优化速度，使用了小整数对象池，避免为整数频繁申请和销毁内存空间。python对小整数的定义是[-5,257],也就是-5到256且包含256，这些整数对象是提前建立好的，不会被垃圾回收，在一个python的程序中，所有位于这个范围内的整数使用的都是同一个对象。同理，单个字母也是这样的。但是当定义2个相同的字符串的时候，引用计数为0，触发垃圾回收 2，大整数对象池（什么时候使用，什么时候创建，小整数池之外的整数）每一个大整数，均创建一个新的对象 3，intern机制 如果定义的变量都是普通字母，不包含其他特殊符号的，默认开启intern机制，共用对象，不会进行新建 总结：小整数[-5,257]共用对象，常驻内存单个字符共用对象，常驻内存单个单词，不可修改，默认开启intern机制，共用对象，引用计数为0，则销毁字符串（含有空格），不可修改，不开启intern机制，不共用对象，引用计数为0，则销毁","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"对象池","slug":"对象池","permalink":"http://yoursite.com/tags/对象池/"}]},{"title":"python之==和is","slug":"迭代、列表生成式和生成器","date":"2017-09-10T03:13:01.000Z","updated":"2017-09-24T09:47:40.423Z","comments":true,"path":"2017/09/10/迭代、列表生成式和生成器/","link":"","permalink":"http://yoursite.com/2017/09/10/迭代、列表生成式和生成器/","excerpt":"","text":"转载自廖雪峰官网：1,迭代 如果给定一个list或tuple等可迭代对象，我们可以通过for循环来遍历这些可迭代对象，这种遍历我们称为迭代 在python中，迭代是通过for in来完成的。 list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代： dicts = {&apos;a&apos;:1,&apos;b&apos;:2,&apos;c&apos;:3} #这里我们迭代的是字典的键 for key in dicts: print(key) #如果要迭代字典的值，可以用： for val in dicts.values(): print(val) 或者： for key in dicts: print(dicts[key]) #如果要同时获取键和值，则可以： for key,val in dicts.items(): print(key,val) 或者： for key in dicts: print(key,dicts[key]) 所以，当我们使用for循环时，只要作用于一个可迭代对象，for循环就可以正常运行，而我们不太关心该对象究竟是list还是其他数据类型。 那么，如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断： &gt;&gt;&gt; from collections import Iterable &gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable) # str是否可迭代 True &gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代 True &gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代 False 最后一个小问题，如果要对list实现类似下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身： &gt;&gt;&gt; for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]): ... print(i, value) ... 0 A 1 B 2 C &gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]: ... print(x, y) ... 1 1 2 4 3 9 小结： 任何可迭代对象都可以作用于for循环，包括我们自定义的数据类型，只要符合迭代条件，就可以使用for循环。 2，列表生成式： 列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。 举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))： &gt;&gt;&gt; list(range(1, 11)) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环： &gt;&gt;&gt; L = [] &gt;&gt;&gt; for x in range(1, 11): ... L.append(x * x) ... &gt;&gt;&gt; L [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list： &gt;&gt;&gt; [x * x for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。 for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方： &gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0] [4, 16, 36, 64, 100]： 还可以使用两层循环，可以生成全排列： &gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;] [&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;] 三层和三层以上的循环就很少用到了。 运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现： &gt;&gt;&gt; import os # 导入os模块，模块的概念后面讲到 &gt;&gt;&gt; [d for d in os.listdir(&apos;.&apos;)] # os.listdir可以列出文件和目录 [&apos;.emacs.d&apos;, &apos;.ssh&apos;, &apos;.Trash&apos;, &apos;Adlm&apos;, &apos;Applications&apos;, &apos;Desktop&apos;, &apos;Documents&apos;, &apos;Downloads&apos;, &apos;Library&apos;, &apos;Movies&apos;, &apos;Music&apos;, &apos;Pictures&apos;, &apos;Public&apos;, &apos;VirtualBox VMs&apos;, &apos;Workspace&apos;, &apos;XCode&apos;] for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value： &gt;&gt;&gt; d = {&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; } &gt;&gt;&gt; for k, v in d.items(): ... print(k, &apos;=&apos;, v) ... y = B x = A z = C 因此，列表生成式也可以使用两个变量来生成list： &gt;&gt;&gt; d = {&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; } &gt;&gt;&gt; [k + &apos;=&apos; + v for k, v in d.items()] [&apos;y=B&apos;, &apos;x=A&apos;, &apos;z=C&apos;] 最后把一个list中所有的字符串变成小写： &gt;&gt;&gt; L = [&apos;Hello&apos;, &apos;World&apos;, &apos;IBM&apos;, &apos;Apple&apos;] &gt;&gt;&gt; [s.lower() for s in L] [&apos;hello&apos;, &apos;world&apos;, &apos;ibm&apos;, &apos;apple&apos;] 3,生成器 通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。 所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。 要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator： &gt;&gt;&gt; L = [x * x for x in range(10)] &gt;&gt;&gt; L [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] &gt;&gt;&gt; g = (x * x for x in range(10)) &gt;&gt;&gt; g &lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt; 创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。 我们可以直接打印出list的每一个元素，但我们怎么打印出generator的每一个元素呢？ 如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值,也可以使用next方式来获取：例子：next(g) == g.next() &gt;&gt;&gt; next(g) 0 &gt;&gt;&gt; next(g) 1 &gt;&gt;&gt; next(g) 4 &gt;&gt;&gt; next(g) 9 &gt;&gt;&gt; next(g) 16 &gt;&gt;&gt; next(g) 25 &gt;&gt;&gt; next(g) 36 &gt;&gt;&gt; next(g) 49 &gt;&gt;&gt; next(g) 64 &gt;&gt;&gt; next(g) 81 &gt;&gt;&gt; next(g) Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; StopIteration 所以，我们创建了一个generator后，基本上永远不会调用next()，而是通过for循环来迭代它，并且不需要关心StopIteration的错误。 generator非常强大。如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。 比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到： 1, 1, 2, 3, 5, 8, 13, 21, 34, … 斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易： def fib(max): n, a, b = 0, 0, 1 while n &lt; max: print(b) a, b = b, a + b n = n + 1 return ‘done’注意，赋值语句： a, b = b, a + b相当于： t = (b, a + b) # t是一个tuplea = t[0]b = t[1]但不必显式写出临时变量t就可以赋值。 上面的函数可以输出斐波那契数列的前N个数： fib(6)112358‘done’仔细观察，可以看出，fib函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。 也就是说，上面的函数和generator仅一步之遥。要把fib函数变成generator，只需要把print(b)改为yield b就可以了： def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return ‘done’这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator，也就是一个生成器： f = fib(6)f打印结果是一个生成器，而且用next()每次执行这个生成器的时候，会在遇到yield的时候进行终止，然后返回yield后面的值，等待下次的调用。 这里，最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。 举个简单的例子，定义一个generator，依次返回数字1，3，5： def odd(): print(‘step 1’) yield 1 print(‘step 2’) yield(3) print(‘step 3’) yield(5)调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值： &gt;&gt;&gt; o = odd() &gt;&gt;&gt; next(o) step 1 1 &gt;&gt;&gt; next(o) step 2 3 &gt;&gt;&gt; next(o) step 3 5 &gt;&gt;&gt; next(o) Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; StopIteration 可以看到，odd不是普通函数，而是generator，在执行过程中，遇到yield就中断，下次又继续执行。执行3次yield后，已经没有yield可以执行了，所以，第4次调用next(o)就报错。 回到fib的例子，我们在循环过程中不断调用yield，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。 同样的，把函数改成generator后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代： &gt;&gt;&gt; for n in fib(6): ... print(n) ... 1 1 2 3 5 8 但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中： &gt;&gt;&gt; g = fib(6) &gt;&gt;&gt; while True: ... try: ... x = next(g) ... print(&apos;g:&apos;, x) ... except StopIteration as e: ... print(&apos;Generator return value:&apos;, e.value) ... break ... g: 1 g: 1 g: 2 g: 3 g: 5 g: 8 Generator return value: done send方法的使用：从下面这个例子可以看出，send的方法使用起来和next功能差不多，只不过send方法会顺便给yield i这个整体一个返回值，剩下的功能就和next一样了注意：使用send（）传值的时候不能在第一次使用，这样会报错，如果第一次就要使用send,则给它传一个Nonesend(None) &gt;&gt;&gt; def test(): i = 0 while i&lt;5: temp = yield i print(temp) i+=1 &gt;&gt;&gt; test() &lt;generator object test at 0x0000000002DAA4C0&gt; &gt;&gt;&gt; t = test() &gt;&gt;&gt; t.__next__() 0 &gt;&gt;&gt; t.__next__() None 1 &gt;&gt;&gt; next(t) None 2 &gt;&gt;&gt; t.send(&apos;hehe&apos;) hehe 3","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"迭代 列表生成式 生成器 yieid","slug":"迭代-列表生成式-生成器-yieid","permalink":"http://yoursite.com/tags/迭代-列表生成式-生成器-yieid/"}]},{"title":"python之内建函数","slug":"getattribute属性","date":"2017-09-10T03:13:01.000Z","updated":"2017-09-24T13:51:22.340Z","comments":true,"path":"2017/09/10/getattribute属性/","link":"","permalink":"http://yoursite.com/2017/09/10/getattribute属性/","excerpt":"","text":"1，map函数 定义：map函数会根据提供的函数对指定序列做映射，生成新的列表 map(function,sequence[,sequence,…]) &gt;&gt;list function是一个函数sequence是一个或者多个学列，取决于function需要几个参数python3中返回的是map对象，需要迭代才能获取对象中的值，可以在外面转换成list对象 参数学列中的每一个元素分别调用function函数，返回包含每次function函数返回的map对象 例1： &gt;&gt;&gt; k = map(lambda x:x*x, [1,2,3]) &gt;&gt;&gt; k &gt;&gt;&gt; for i in k: print(i) 1 4 9 &gt;&gt;&gt; k =list(map(lambda x:x*x, [1,2,3])) &gt;&gt;&gt; k 1 4 9 例2： #函数需要2个参数的情况 &gt;&gt;&gt; m = list(map(lambda x,y:x+y,[1,2,3],[4,5,6])) &gt;&gt;&gt; m [5, 7, 9] 例3：上面两个例子都是用匿名函数的方式，下面来看不使用匿名函数的方式： &gt;&gt;&gt; def f1(x,y): return (x,y) &gt;&gt;&gt; a1 = [1,2,3,4,5,6] &gt;&gt;&gt; a2 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;] &gt;&gt;&gt; list(map(f1,a1,a2)) [(1, &apos;a&apos;), (2, &apos;b&apos;), (3, &apos;c&apos;), (4, &apos;d&apos;), (5, &apos;e&apos;), (6, &apos;f&apos;)] 2，filter 定义：filter函数会对制定序列执行过滤、筛选操作 filter(function or None,squence)&gt;&gt;&gt;list,tuple,or string function:接受一个参数，返回布尔值True或False sequence:序列可以是str,tuple,list filter函数会对序列参数sequence中的每个元素调用function函数，最后返回的结果包含调用结果为True的元素。返回值的类型和参数sequence的类型相同 例1： &gt;&gt;&gt; list(filter(lambda x:x%2,[1,2,3,4,5,6,7,8])) [1, 3, 5, 7] 3，sorted函数 定义：对参数进行排序返回新的列表，如果是字母则通过ASII码进行排序 例1：正序排序 &gt;&gt;&gt; sorted([1,2,3,5,3,12,4,1234,34,343]) [1, 2, 3, 3, 4, 5, 12, 34, 343, 1234] 例2：倒序排序 &gt;&gt;&gt; sorted([4,66,1,65,23,8,5,],reverse = True) [66, 65, 23, 8, 5, 4, 1] 例3：字母排序 &gt;&gt;&gt; sorted([&apos;a&apos;,&apos;c&apos;,&apos;e&apos;,&apos;b&apos;,&apos;f&apos;]) [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;e&apos;, &apos;f&apos;] #如果是单词的话会通过它们首字母的asii码进行排序 &gt;&gt;&gt; sorted([&apos;hello&apos;,&apos;world&apos;,&apos;name&apos;,&apos;args&apos;]) [&apos;args&apos;, &apos;hello&apos;, &apos;name&apos;, &apos;world&apos;]","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"内建函数","slug":"内建函数","permalink":"http://yoursite.com/tags/内建函数/"}]},{"title":"python之装饰器","slug":"装饰器","date":"2017-09-10T03:13:01.000Z","updated":"2017-09-24T10:19:22.335Z","comments":true,"path":"2017/09/10/装饰器/","link":"","permalink":"http://yoursite.com/2017/09/10/装饰器/","excerpt":"","text":"装饰器的作用在原来代码的基础上进行功能扩展 例如：原来我们有2个方法，f1和f2 def f1(): print(&apos;f1&apos;) def f2(): print(&apos;f2&apos;) f1() f2() 现在我们需要给这两个方法调用前加一个验证，验证成功就调用，失败则不调用：首先我们使用一种普通方法： def w1(func): def inner(): print(‘正在验证中’) if True: func() else: print(‘验证失败，请重试’) return inner def f1(): print(&apos;f1&apos;) def f2(): print(&apos;f2&apos;) x = w1(f1) x() y = w1(f2) y() 这种方式基本实现了所需要的验证功能 接下来我们使用通过用装饰器实现的写法： def w1(func): def inner(): print(‘正在验证’) if True: func() else: print(‘验证失败，请重试’) return inner @w1 #相当于w1(f1) def f1(): print(&apos;f1&apos;) @w1 #相当于w1(f2) def f2(): print(&apos;f2&apos;) f1() f2() 类装饰器 class Test(object): def __init__(self,fn): print(&apos;初始化&apos;) print(&apos;fn的名字是{0}&apos;.format(fn.__name__)) self.__fn = fn def __call__(self): print(&apos;---装饰器中的功能---&apos;) self.__fn() @Test # test = Test(test) #这里的这一步就相当于 #也就是实例化一个对象，实例化的时候会触发__init__函数执行，现在 #test 也就等于了一个已经实例化后的对象 #如果这里在调用test(),就会触发类里的__call__方法 def test(): print(&apos;====test====&apos;) test() &gt;&gt;&gt;初始化 &gt;&gt;&gt;fn的名字是test &gt;&gt;&gt;---装饰器中的功能--- &gt;&gt;&gt;====test====","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"装饰器","slug":"装饰器","permalink":"http://yoursite.com/tags/装饰器/"}]},{"title":"python之进程的创建","slug":"进程的创建fork","date":"2017-09-10T03:13:01.000Z","updated":"2017-09-25T02:45:50.019Z","comments":true,"path":"2017/09/10/进程的创建fork/","link":"","permalink":"http://yoursite.com/2017/09/10/进程的创建fork/","excerpt":"","text":"1，进程和程序 编写完毕的代码，在没有运行的时候，称之为程序正在运行着的代码，就成为进程进程，除了包含代码以外，还有需要运行的环境等，所以和程序是有区别的 2，fork()","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"进程","slug":"进程","permalink":"http://yoursite.com/tags/进程/"}]},{"title":"python之==和is","slug":"等号和is","date":"2017-09-10T03:13:01.000Z","updated":"2017-09-23T15:14:35.390Z","comments":true,"path":"2017/09/10/等号和is/","link":"","permalink":"http://yoursite.com/2017/09/10/等号和is/","excerpt":"","text":"关于 == 和 is 判断内容的时候使用== #这里比较的是两个对象中的值，而不进行内存地址的检测，返回布尔值 &gt;&gt;&gt;a = [1,2,3] &gt;&gt;&gt;b = [1,2,3] &gt;&gt;&gt;a == b True 判断是否指向同一个对象的时候用is &gt;&gt;&gt;a = [1,2,3] &gt;&gt;&gt;b = [1,2,3] &gt;&gt;&gt; id(a) 45600072 &gt;&gt;&gt; id(b) 45721032 &gt;&gt;&gt; a is b False 这里需要注意的是： 1,整数在程序中的使用非常广泛，Python为了优化速度，使用了小整数对象池，避免为整数频繁申请和销毁内存空间。python对小整数的定义是[-5,257],也就是-5到256且包含256，这些整数对象是提前建立好的，在一个python的程序中，所有位于这个范围内的整数使用的都是同一个对象。同理，单个字母也是这样的。2,如果定义的变量都是普通字母，不包含其他特殊符号的，默认开启intern机制，共用对象，不会进行新建例子： &gt;&gt;&gt; a = 100 &gt;&gt;&gt; b = 100 &gt;&gt;&gt; a is b True &gt;&gt;&gt; a = &apos;hehe&apos; &gt;&gt;&gt; b = &apos;hehe&apos; &gt;&gt;&gt; a is b True","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"运算符","slug":"运算符","permalink":"http://yoursite.com/tags/运算符/"}]},{"title":"python之集合","slug":"集合","date":"2017-09-10T03:13:01.000Z","updated":"2017-09-24T14:36:42.107Z","comments":true,"path":"2017/09/10/集合/","link":"","permalink":"http://yoursite.com/2017/09/10/集合/","excerpt":"","text":"定义：python的set和其他语言类似, 是一个无序不重复元素集, 基本功能包括关系测试和消除重复元素. 集合对象还支持union(联合), intersection(交), difference(差)和sysmmetric difference(对称差集)等数学运算. sets 支持 x in set, len(set),和 for x in set。作为一个无序的集合，sets不记录元素位置或者插入点。因此，sets不支持 indexing, slicing, 或其它类序列（sequence-like）的操作。 1，集合功能之一：列表去重因为集合是无序不重复元素集，利用这一特性可以进行列表的去重操作例： &gt;&gt;&gt; a = [11,23,345,657,453,123,11,23,345,657,453,123] &gt;&gt;&gt; b = set(a) &gt;&gt;&gt; b {453, 11, 657, 23, 345, 123} &gt;&gt;&gt; a = list(b) &gt;&gt;&gt; a [453, 11, 657, 23, 345, 123] 2，集合功能之二：交集 &gt;&gt;&gt; a = {&apos;a&apos;,&apos;b&apos;,&apos;d&apos;,&apos;f&apos;,&apos;l&apos;,&apos;k&apos;,&apos;m&apos;} &gt;&gt;&gt; b = {&apos;k&apos;,&apos;s&apos;,&apos;q&apos;,&apos;k&apos;,&apos;y&apos;,&apos;z&apos;,&apos;b&apos;} &gt;&gt;&gt; a&amp;b {&apos;b&apos;, &apos;k&apos;} 3，集合功能之三：并集 &gt;&gt;&gt; a = {&apos;a&apos;,&apos;b&apos;,&apos;d&apos;,&apos;f&apos;,&apos;l&apos;,&apos;k&apos;,&apos;m&apos;} &gt;&gt;&gt; b = {&apos;k&apos;,&apos;s&apos;,&apos;q&apos;,&apos;k&apos;,&apos;y&apos;,&apos;z&apos;,&apos;b&apos;} &gt;&gt;&gt; a | b {&apos;s&apos;, &apos;k&apos;, &apos;q&apos;, &apos;m&apos;, &apos;z&apos;, &apos;l&apos;, &apos;f&apos;, &apos;a&apos;, &apos;d&apos;, &apos;y&apos;, &apos;b&apos;} 4，集合功能之四：差集 &gt;&gt;&gt; a = {&apos;a&apos;,&apos;b&apos;,&apos;d&apos;,&apos;f&apos;,&apos;l&apos;,&apos;k&apos;,&apos;m&apos;} &gt;&gt;&gt; b = {&apos;k&apos;,&apos;s&apos;,&apos;q&apos;,&apos;k&apos;,&apos;y&apos;,&apos;z&apos;,&apos;b&apos;} &gt;&gt;&gt; a-b #a中有的而b中没有的 {&apos;m&apos;, &apos;l&apos;, &apos;f&apos;, &apos;a&apos;, &apos;d&apos;} 5，集合功能之五：对称差集 &gt;&gt;&gt; a = {&apos;a&apos;,&apos;b&apos;,&apos;d&apos;,&apos;f&apos;,&apos;l&apos;,&apos;k&apos;,&apos;m&apos;} &gt;&gt;&gt; b = {&apos;k&apos;,&apos;s&apos;,&apos;q&apos;,&apos;k&apos;,&apos;y&apos;,&apos;z&apos;,&apos;b&apos;} &gt;&gt;&gt; a^b #a有的，b没有的，b有的，a没有的 {&apos;s&apos;, &apos;q&apos;, &apos;z&apos;, &apos;m&apos;, &apos;l&apos;, &apos;f&apos;, &apos;a&apos;, &apos;y&apos;, &apos;d&apos;}","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"set集合","slug":"set集合","permalink":"http://yoursite.com/tags/set集合/"}]},{"title":"python之垃圾回收","slug":"垃圾回收","date":"2017-01-02T14:56:34.000Z","updated":"2017-12-17T04:46:13.530Z","comments":true,"path":"2017/01/02/垃圾回收/","link":"","permalink":"http://yoursite.com/2017/01/02/垃圾回收/","excerpt":"","text":"垃圾回收机制（GC） 关于垃圾回收高级语言里都采用了垃圾回收机制，而不再是C，C++里用户自己管理内存。在python里采用的是引用技术机制为主，标记-清除和分代手机两种机制为辅的策略 关于引用计数python里每个东西都是对象，通过底层的一个方法对当前对象的引用进行计数,当一个对象有新的引用的时候，它的计数就会增加，当引用它的对象被删除，它的引用计数就减少，当引用计数为0的时候，该对象生命就结束了。 优点：1，简单2，实时性：一旦没有引用，内存就直接释放了。不用想其他机制等待特定时机，实时性带来的另外一个好处，处理回收内存的时间分摊了，不会等到特定时间做特定的事情。 缺点：1，维护引用计数消耗资源2，循环引用的问题，已经通过隔代回收的方式进行了处理，首先创建对象之后在特定时间会进行检测2个对象之间是否在进行相互引用，如果是则进行回收。然后把没被清除的对象移动到下个数据链中。然后继续进行在特定时间进行检测。 更底层的进行垃圾回收管理需要引入gc模块进行管理，这里就不进行深入理解了。","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"垃圾回收","slug":"垃圾回收","permalink":"http://yoursite.com/tags/垃圾回收/"}]},{"title":"深入python之浅拷贝和深拷贝","slug":"深拷贝和浅拷贝","date":"2017-01-01T03:13:01.000Z","updated":"2017-12-17T03:22:18.089Z","comments":true,"path":"2017/01/01/深拷贝和浅拷贝/","link":"","permalink":"http://yoursite.com/2017/01/01/深拷贝和浅拷贝/","excerpt":"","text":"关于python中的浅拷贝和深拷贝在Python中，首先要讲的就是等号赋值了，其实这种拷贝只是给源对象新增一个标签而已，指向的还是同一个对象： 例：&gt;&gt;&gt;a = [1,2,3] &gt;&gt;&gt;b = a #打印a的内存地址 &gt;&gt;&gt;id(a) 45817096 #打印b的内存地址 &gt;&gt;&gt;id(b) 45817096 #这里的a和b指向的是同一个对象 接下来就是我们要讲的浅拷贝和深拷贝，实现深浅拷贝首先需要引入copy模块: 1：浅拷贝,使用copy模块下的copy()方法实现： &gt;&gt;&gt;import copy &gt;&gt;&gt;a = [1,2,3,4] &gt;&gt;&gt;b = copy.copy(a) &gt;&gt;&gt; id(a) 47818184 &gt;&gt;&gt; id(b) 47856904 # 在这里我们发现b和a的内存地址不同，相当于复制一份新的列表[1,2,3,4]给了b,如果现在修改a的值，b的值不会随之变化： &gt;&gt;&gt; a.append(10) &gt;&gt;&gt; a [1, 2, 3, 4, 10] &gt;&gt;&gt; b [1, 2, 3, 4] # 我们接着往下走： &gt;&gt;&gt; aa = [1,2,3,[&apos;a&apos;,&apos;b&apos;]] &gt;&gt;&gt; bb = copy.copy(aa) &gt;&gt;&gt; id(aa) 47914120 &gt;&gt;&gt; id(bb) 47697096 # 接着我们继续输出列表嵌套内的列表的内存地址 &gt;&gt;&gt; id(aa[3]) 47696776 &gt;&gt;&gt; id(bb[3]) 47696776 # 在这里我们发现内部嵌套的列表的内存地址是相同的，这里就说明了浅拷贝仅仅只是拷贝了父对象，而不会拷贝扶对象内部的子对象 2：深拷贝，使用copy模块下的deepcopy()方法实现： &gt;&gt;&gt;import copy &gt;&gt;&gt;a = [1,2,3,4] &gt;&gt;&gt;b = copy.deepcopy(a) &gt;&gt;&gt; id(a) 47818184 &gt;&gt;&gt; id(b) 47856904 #这里可以看到，如果当前拷贝对象没有子对象的时候，copy()和deep()没有区别 #接着往下看： &gt;&gt;&gt; a = [1,2,3,4,[&apos;x&apos;,&apos;y&apos;]] &gt;&gt;&gt; b = copy.deepcopy() &gt;&gt;&gt; id(a[4]) 47733896 &gt;&gt;&gt; id(b[4]) 47914056 #这里我们发现，深拷贝会拷贝当前对象及其子对象，不论父对象嵌套多少子对象都会进行完全拷贝 我们发现，刚才举例的时候只是用到了列表，实际工作中用到的不止有列表这么一种数据类型，我们不妨试一下其他的类型，比如试一试元祖： &gt;&gt;&gt; a = (1,2,3,4,[&apos;aa&apos;,&apos;bb&apos;]) &gt;&gt;&gt; b = copy.copy(a) &gt;&gt;&gt; id(a) 45195112 &gt;&gt;&gt; id(b) 45195112 &gt;&gt;&gt; id(a[4]) 46124808 &gt;&gt;&gt; id(b[4]) 46124808 #这里我们发现浅拷贝元祖的时候父对象也没有实现拷贝，还是指向了原来对象的内存地址 &gt;&gt;&gt; c = copy.deepcopy(a) &gt;&gt;&gt; id(c) 45853160 &gt;&gt;&gt; id(c[4]) 46169224 &gt;&gt;&gt; id(a[4]) 46124808 #而深拷贝还是一如既往的一致，父对象和子对象都进行了拷贝 #其实这里python默认帮我们进行了类型检测，如果是不可变类型则无法进行浅拷贝，只可以执行深拷贝，这个需要重点记忆，工作中可能就莫名出现此类BUG； 小结： copy.copy() 浅拷贝 只拷贝父对象，不会拷贝对象的内部的子对象。 copy.deepcopy() 深拷贝 拷贝对象及其子对象 如果拷贝的类型是不可变类型的时候，浅拷贝不会拷贝父对象，只有深拷贝会执行拷贝","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"模块 copy","slug":"模块-copy","permalink":"http://yoursite.com/tags/模块-copy/"}]}]}